在一个整型数组中，只有一个数字出现一次，其他数组都是成对出现的，请找出那个只出现一次的数字。
例如：
数组中有：1 2 3 4 5 1 2 3 4，只有5出现一次，其他数字都出现2次，找出5
#include<stdio.h>
int main()
{
	int arr[] = { 1,2,3,4,5,1,2,3,4 };
	int sum = arr[0];
	for (int i = 1;i < sizeof(arr) / sizeof(arr[0]);i++)
	{
		sum ^= arr[i];
	}
	printf("%d", sum);
}

获取一个整数二进制序列中所有的偶数位和奇数位，分别打印出二进制序列
/*
思路：
1. 提取所有的奇数位，如果该位是1，输出1，是0则输出0
2. 以同样的方式提取偶数位置
 检测num中某一位是0还是1的方式：
   1. 将num向右移动i位
   2. 将移完位之后的结果与1按位与，如果：
      结果是0，则第i个比特位是0
      结果是非0，则第i个比特位是1
*/
#include<stdio.h>
int main()
{
	int n;
	scanf_s("%d", &n);
	printf("奇数位：");
	for (int i = 31;i >= 1;i -= 2)
	{
		printf("%d ", (n >> i) & 1);
	}
	printf("\n");
	printf("偶数位：");
	for (int i = 30;i >= 0;i -= 2)
	{
		printf("%d ", (n >> i) & 1);
	}
}
写一个函数返回参数二进制中 1 的个数。
/*
方法一：
思路：
循环进行以下操作，直到n被缩减为0：
   1. 用该数据模2，检测其是否能够被2整除
   2. 可以：则该数据对应二进制比特位的最低位一定是0，否则是1，如果是1给计数加1
   3. 如果n不等于0时，继续1
*/
int NumberOf1(int n)
{
	int count = 0;
	while(n)
	{
		if(n%2==1)
			count++;
		n = n/2;
	}
	return count;
}
/*
上述方法缺陷：进行了大量的取模以及除法运算，取模和除法运算的效率本来就比较低。
方法二思路：
一个int类型的数据，对应的二进制一共有32个比特位，可以采用位运算的方式一位一位的检测，具体如下
*/
int NumberOf1(unsigned int n)
{
	int count = 0;
	int i = 0;
	for(i=0; i<32; i++)
	{
		if(((n>>i)&1) == 1)
			count++;
	}
	return count;
}

/*
方法二优点：用位操作代替取模和除法运算，效率稍微比较高
  缺陷：不论是什么数据，循环都要执行32次
方法三：
思路：采用相邻的两个数据进行按位与运算
举例：
9999：‭10 0111 0000 1111‬
第一次循环：n=9999   n=n&(n-1)=9999&9998= 9998
第二次循环：n=9998   n=n&(n-1)=9998&9997= 9996
第三次循环：n=9996   n=n&(n-1)=9996&9995= 9992
第四次循环：n=9992   n=n&(n-1)=9992&9991= 9984
第五次循环：n=9984   n=n&(n-1)=9984&9983= 9728
第六次循环：n=9728   n=n&(n-1)=9728&9727= 9216
第七次循环：n=9216   n=n&(n-1)=9216&9215= 8192
第八次循环：n=8192   n=n&(n-1)=8192&8191= 0
可以观察下：此种方式，数据的二进制比特位中有几个1，循环就循环几次，而且中间采用了位运算，处理起来比较高效
*/
int NumberOf1(int n)
{
	int count = 0;
	while(n)
	{
		n = n&(n-1);
		count++;
	}
	return count;
}
编程实现：两个int（32位）整数m和n的二进制表达中，有多少个位(bit)不同？ 
#include<stdio.h>
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int num=n^m;//对n和m进行异或操作，然后统计1的数量
    int count=0;
    while(num)
    {
        num&=(num-1);
        count++;
    }
    printf("%d",count);
}
